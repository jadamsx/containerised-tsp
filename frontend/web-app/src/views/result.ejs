<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test Result</title>
    <style>
      body {
          font-family: "Arial", sans-serif;
          background-color: #f4f4f4;
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100vh;
      }

      h1 {
          color: #333;
      }

      p {
          margin: 8px 0;
          color: #333;
          text-align: center; /* Center align paragraphs */
      }

      canvas {
          margin-top: 16px;
          border: 1px solid #333;
          display: block; /* Make canvas a block element for centering */
          margin: 0 auto; /* Center align canvas */
      }

      button {
          padding: 10px;
          background-color: #3498db;
          color: #fff;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          margin-top: 16px;
      }

      button:hover {
          background-color: #2980b9;
      }

      /* Center result content */
      #resultContent {
          display: none;
          text-align: center; /* Center align text within resultContent div */
      }
  </style
  </head>
  <body>
    <h1>Test Result</h1>

    <div id="loadingMessage" style="display: block">
      <p>Loading...</p>
    </div>

    <div id="resultContent" style="display: none">
      <p>Graph Name: <span id="graphName"></span></p>
      <p>Expected Cost: <span id="expectedCost"></span></p>
      <p>Actual Cost: <span id="actualCost"></span></p>
      <p>Time: <span id="time"></span></p>
      <p>Accuracy : <span id="accuracy"></span>%</p>

      <canvas id="tourCanvas" width="600" height="600"></canvas>
      <div>
        <button onclick="window.location.href='/';">Return to Main Page</button>
      </div>
    </div>

    <script>
      // Function to draw cities and connections on the canvas
      function drawTour(data) {
        const canvas = document.getElementById("tourCanvas");
        const ctx = canvas.getContext("2d");
        const coordinates = data.Coordinates;
        const tour = data.ActualTour;

        // Margin to leave space around the points
        const margin = 20;

        // Find bounding box of coordinates with margin
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        coordinates.forEach((coord) => {
          minX = Math.min(minX, coord[0]);
          minY = Math.min(minY, coord[1]);
          maxX = Math.max(maxX, coord[0]);
          maxY = Math.max(maxY, coord[1]);
        });

        // Add margin
        minX -= margin;
        minY -= margin;
        maxX += margin;
        maxY += margin;

        // Calculate scaling factor
        const scaleFactor = Math.min(
          canvas.width / (maxX - minX),
          canvas.height / (maxY - minY)
        );

        // Calculate translation offsets
        const xOffset = (canvas.width - (maxX - minX) * scaleFactor) / 2;
        const yOffset = (canvas.height - (maxY - minY) * scaleFactor) / 2;

        // Draw cities
        ctx.fillStyle = "#3498db";
        coordinates.forEach((coord) => {
          const scaledX = (coord[0] - minX) * scaleFactor + xOffset;
          const scaledY = (coord[1] - minY) * scaleFactor + yOffset;
          ctx.beginPath();
          ctx.arc(scaledX, scaledY, 5, 0, 2 * Math.PI);
          ctx.fill();
        });

        // Draw connections based on the tour
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(
          (coordinates[tour[0]][0] - minX) * scaleFactor + xOffset,
          (coordinates[tour[0]][1] - minY) * scaleFactor + yOffset
        );
        for (let i = 1; i < tour.length; i++) {
          const scaledX =
            (coordinates[tour[i]][0] - minX) * scaleFactor + xOffset;
          const scaledY =
            (coordinates[tour[i]][1] - minY) * scaleFactor + yOffset;
          ctx.lineTo(scaledX, scaledY);
        }
        ctx.lineTo(
          (coordinates[tour[0]][0] - minX) * scaleFactor + xOffset,
          (coordinates[tour[0]][1] - minY) * scaleFactor + yOffset
        );
        ctx.stroke();
      }

      // Function to update the result content
      function updateResultContent(data) {
        document.getElementById("graphName").innerText = data.GraphName;
        document.getElementById("expectedCost").innerText = data.ExpectedCost;
        document.getElementById("actualCost").innerText = data.ActualCost;
        document.getElementById("time").innerText = data.Time;
        document.getElementById("accuracy").innerText = data.Accuracy;

        // Draw tour on canvas
        drawTour(data);
      }

      // Function to fetch result data from the server
      function fetchResultData() {
        fetch("/result")
          .then((response) => response.json())
          .then((data) => {
            if (data.result) {
              // Hide loading message and display result content
              document.getElementById("loadingMessage").style.display = "none";
              document.getElementById("resultContent").style.display = "block";

              // Update the result content
              updateResultContent(data.result);
            } else {
              // Result not yet available, retry after 1 second
              setTimeout(fetchResultData, 1000);
            }
          })
          .catch((error) => console.error(error));
      }

      // Call the fetchResultData function to start fetching result data
      fetchResultData();
    </script>
  </body>
</html>
